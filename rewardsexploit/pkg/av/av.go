package av

import (
	"bytes"
	"fmt"
	"github.com/lc/rewardsexploit/pkg/login"
	"github.com/sirupsen/logrus"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
)

func NewAccountVerifier(to string) *AccountVerifier {
	return &AccountVerifier{
		to: to,
		loginer: login.NewLoginWorker(),
		linkRegexp: regexp.MustCompile(`https://.*`),
		http: &http.Client{Timeout: 10*time.Second},
	}
}

type AccountVerifier struct {
	to string
	linkRegexp *regexp.Regexp
	loginer *login.LoginWorker
	http *http.Client
}

func (a *AccountVerifier) Handler(origin net.Addr, from string, to []string, data []byte) error {
	msg, _ := mail.ReadMessage(bytes.NewReader(data))
	subject := msg.Header.Get("Subject")
	if !strings.Contains(subject, "Confirm Your Rewards Account") {
		return nil
	}

	//logrus.WithFields(logrus.Fields{"func":"av.Handler"}).Infof("received confirmation email from %v", from)

	out, err := ioutil.ReadAll(msg.Body)
	if err != nil {
		return err
	}
	regex := regexp.MustCompile(`https://.*`)
	matches := regex.FindAllString(string(out),10)

	confirmationToken := ""
	for _, match := range matches {
		if strings.Contains(match, "/confirm/") {
			out, _ := url.Parse(strings.Split(match,"\"")[0])
			tok := strings.Split(out.Path,"/confirm/")[1]
			if tok == "" {
				return nil
			}
			confirmationToken = tok+"?"+out.RawQuery
			goto done
		}
	}
done:
	retries := 0
	retry:
	resp, err := a.http.Post("https://rewards.███.com/api/EN/Profile/Confirm?randomId="+confirmationToken, "",nil)
	if err != nil {
		return err
	}

	io.Copy(ioutil.Discard, resp.Body)
	resp.Body.Close()

	if resp.StatusCode == 200 {
		accEmail := strings.ToLower(to[0])
		logrus.WithFields(logrus.Fields{"func":"av.Handler"}).Infof("verified account: %s", accEmail)
		a.TransferCredits(accEmail)
	} else {
		if retries < 15 {
			retries++
			goto retry
		} else {
			logrus.WithFields(logrus.Fields{"func":"av.Handler"}).Errorf("verification failed, token: %s", confirmationToken)
		}
	}
	return nil
}
